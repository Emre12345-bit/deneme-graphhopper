package com.graphhopper.routing;

import com.graphhopper.routing.ev.*;
import com.graphhopper.routing.util.EncodingManager;
import com.graphhopper.routing.weighting.Weighting;
import com.graphhopper.config.Profile;
import com.graphhopper.storage.BaseGraph;
import com.graphhopper.util.PMap;
import com.graphhopper.util.EdgeIteratorState;
import com.graphhopper.traffic.TrafficAwareCustomModelCreator;
import com.graphhopper.traffic.SpeedLimitService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Set;
import java.util.Map;

/**
 * Hƒ±z limit verilerini kullanarak weighting olu≈üturan factory
 */
@Singleton
public class SpeedLimitAwareWeightingFactory {
    private static final Logger logger = LoggerFactory.getLogger(SpeedLimitAwareWeightingFactory.class);
    
    private final BaseGraph graph;
    private final EncodingManager encodingManager;
    private final TrafficAwareCustomModelCreator customModelCreator;
    
    // Speed limit edge encodings
    private final DecimalEncodedValue speedLimitEnc;
    private final BooleanEncodedValue hasSpeedLimitEnc;
    
    @Inject
    public SpeedLimitAwareWeightingFactory(BaseGraph graph, TrafficAwareCustomModelCreator customModelCreator) {
        this.graph = graph;
        // BaseGraph'da getEncodingManager() yok, bu y√ºzden encoding'leri doƒürudan olu≈üturuyoruz
        this.encodingManager = null; // EncodingManager'ƒ± kullanmayacaƒüƒ±z
        this.customModelCreator = customModelCreator;
        
        // Speed limit encodings'i doƒürudan olu≈ütur (BaseGraph'da EncodingManager yok)
        this.speedLimitEnc = new DecimalEncodedValueImpl("speed_limit", 8, 1.0, false);
        this.hasSpeedLimitEnc = new SimpleBooleanEncodedValue("has_speed_limit", false);
        logger.info("Speed limit encodings created directly");
        
                 logger.info("SpeedLimitAwareWeightingFactory initialized");
     }
     
     /**
      * Ara√ß tipi adƒ±nƒ± getir
      */
     private String getCarTypeName(int carTypeId) {
         switch (carTypeId) {
             case 1: return "Otomobil";
             case 2: return "Minib√ºs";
             case 3: return "Otob√ºs";
             case 4: return "Kamyonet";
             case 5: return "Kamyon";
             case 6: return "√áekici";
             default: return "Unknown";
         }
     }
    
    /**
     * Hƒ±z limit verilerini kullanarak weighting olu≈ütur
     */
    public Weighting createSpeedLimitAwareWeighting(Profile profile, PMap requestHints, Weighting baseWeighting) {
        // Check if profile is foot or bike - skip speed limit weighting for these profiles
        String profileName = profile.getName();
        if (profileName != null && (profileName.equals("foot") || profileName.equals("bike"))) {
            logger.debug("Skipping speed limit weighting for {} profile - not applicable for pedestrians/cyclists", profileName);
            return baseWeighting;
        }
        
        // Hƒ±z limit parametrelerini kontrol et
        Integer carTypeId = requestHints.getInt("car_type_id", 0);
        boolean speedLimitEnabled = requestHints.getBool("speed_limit_enabled", false);
        
        // Mevcut avoidance parametrelerini kontrol et
        boolean avoidEdsRoads = requestHints.getBool("avoid_eds_roads", false);
        boolean avoidCustomAreas = requestHints.getBool("avoid_custom_areas", false);
        
        // Hƒ±z limiti false olsa bile EDS/Custom Area kontrol√º yap
        if (!speedLimitEnabled || carTypeId == 0) {
            if (avoidEdsRoads || avoidCustomAreas) {
                logger.info("Speed limit disabled but avoidance enabled - Creating avoidance-only weighting");
                return new AvoidanceOnlyWeighting(baseWeighting, avoidEdsRoads, avoidCustomAreas);
            } else {
                logger.debug("Speed limit weighting disabled and no avoidance needed");
                return baseWeighting;
            }
        }
        
                 logger.info("‚öñÔ∏è WEIGHTING CREATION: Creating speed limit aware weighting - CarType: {} ({}), AvoidEDS: {}, AvoidCustomAreas: {}", 
                    carTypeId, getCarTypeName(carTypeId), avoidEdsRoads, avoidCustomAreas);
        
        try {
            // Hƒ±z limit weighting'i olu≈ütur
            SpeedLimitAwareWeighting speedLimitWeighting = new SpeedLimitAwareWeighting(
                baseWeighting, speedLimitEnc, hasSpeedLimitEnc, carTypeId, avoidEdsRoads, avoidCustomAreas, requestHints);
            
                         logger.info("‚úÖ WEIGHTING CREATED: Speed limit aware weighting created successfully");
            return speedLimitWeighting;
            
        } catch (Exception e) {
            logger.error("Failed to create speed limit aware weighting: {}", e.getMessage());
            // Hata durumunda sadece avoidance weighting'i dene
            if (avoidEdsRoads || avoidCustomAreas) {
                return new AvoidanceOnlyWeighting(baseWeighting, avoidEdsRoads, avoidCustomAreas);
            }
            return baseWeighting;
        }
    }
    
    /**
     * Hƒ±z limit verilerini kullanarak weighting hesaplayan sƒ±nƒ±f
     */
    public class SpeedLimitAwareWeighting implements Weighting {
        private final Weighting baseWeighting;
        private final DecimalEncodedValue speedLimitEnc;
        private final BooleanEncodedValue hasSpeedLimitEnc;
        private final int carTypeId;
        private final boolean avoidEdsRoads;
        private final boolean avoidCustomAreas;
        private final PMap requestHints;
        
        // Hƒ±z limit aƒüƒ±rlƒ±k fakt√∂rleri
        private static final double AVOIDANCE_PENALTY_FACTOR = 10.0;  // Ka√ßƒ±nƒ±lmasƒ± gereken yollar i√ßin b√ºy√ºk ceza
        
        public SpeedLimitAwareWeighting(Weighting baseWeighting, DecimalEncodedValue speedLimitEnc, 
                                      BooleanEncodedValue hasSpeedLimitEnc, int carTypeId, 
                                      boolean avoidEdsRoads, boolean avoidCustomAreas, PMap requestHints) {
            this.baseWeighting = baseWeighting;
            this.speedLimitEnc = speedLimitEnc;
            this.hasSpeedLimitEnc = hasSpeedLimitEnc;
            this.carTypeId = carTypeId;
            this.avoidEdsRoads = avoidEdsRoads;
            this.avoidCustomAreas = avoidCustomAreas;
            this.requestHints = requestHints;
        }
        
        @Override
        public double calcEdgeWeight(EdgeIteratorState edgeState, boolean reverse) {
            // Edge ID ge√ßerliliƒüini kontrol et
            int edgeId = edgeState.getEdge();
            int maxEdgeId = graph.getEdges();
            
            if (edgeId < 0 || edgeId >= maxEdgeId) {
                logger.warn("Invalid edge ID in SpeedLimitAwareWeighting: {} (max: {})", edgeId, maxEdgeId - 1);
                // Ge√ßersiz edge i√ßin base weighting'i d√∂nd√ºr
                return baseWeighting.calcEdgeWeight(edgeState, reverse);
            }
            
            // Base weighting'i hesapla
            double baseWeight = baseWeighting.calcEdgeWeight(edgeState, reverse);
            
                    // √ñnce ka√ßƒ±nma aƒüƒ±rlƒ±ƒüƒ±nƒ± hesapla (EDS √∂ncelikli)
        double avoidanceWeight = calculateAvoidanceWeight(edgeState, reverse);
        
        // EDS edge ise hƒ±z limit bonus'u uygulama
        if (avoidanceWeight > 1.0) {
            // EDS edge - sadece ka√ßƒ±nma aƒüƒ±rlƒ±ƒüƒ±nƒ± kullan
            double totalWeight = baseWeight * avoidanceWeight;
            logger.debug("EDS edge {} - using only avoidance weight: {}", edgeId, totalWeight);
            return totalWeight;
        }
        
        // Sonra hƒ±z limit aƒüƒ±rlƒ±ƒüƒ±nƒ± hesapla (sadece normal yollarda)
        double speedLimitWeight = calculateSpeedLimitWeight(edgeState, reverse);
        
        // Toplam aƒüƒ±rlƒ±ƒüƒ± hesapla - EDS √∂ncelikli
        double totalWeight = baseWeight * avoidanceWeight * speedLimitWeight;
            
            // Debug log
            if (logger.isDebugEnabled()) {
                boolean hasSpeedLimit = hasSpeedLimitEnc.getBool(reverse, edgeId, graph.getEdgeAccess());
                boolean isEdsEdge = isEdsEdge(edgeId);
                boolean isCustomAreaEdge = isCustomAreaEdge(edgeId);
                
                                 if (hasSpeedLimit || isEdsEdge || isCustomAreaEdge) {
                     double osmSpeedLimit = getOsmSpeedLimit(edgeState, reverse);
                     
                     // Request hints'ten API hƒ±z limitini al
                     @SuppressWarnings("unchecked")
                     Map<Integer, SpeedLimitService.SpeedLimitData> speedLimitData = 
                         (Map<Integer, SpeedLimitService.SpeedLimitData>) requestHints.getObject("speed_limit_data", null);
                     int apiSpeedLimit = 0;
                     String speedLimitTitle = "";
                     if (speedLimitData != null && speedLimitData.containsKey(edgeId)) {
                         SpeedLimitService.SpeedLimitData speedLimit = speedLimitData.get(edgeId);
                         if (speedLimit != null) {
                             apiSpeedLimit = speedLimit.speedLimit;
                             speedLimitTitle = speedLimit.title;
                         }
                     }
                     
                     // Log seviyesini belirle
                     if (isEdsEdge || isCustomAreaEdge) {
                         logger.info("üö® CRITICAL EDGE {}: base={}, avoidance={}, total={}, isEds={}, isCustomArea={}", 
                                   edgeId, baseWeight, avoidanceWeight, totalWeight, isEdsEdge, isCustomAreaEdge);
                     } else if (hasSpeedLimit) {
                         logger.info("üöó SPEED LIMIT EDGE {}: base={}, speedLimit={}, total={}, osmSpeedLimit={}, apiSpeedLimit={}, title={}", 
                                   edgeId, baseWeight, speedLimitWeight, totalWeight, osmSpeedLimit, apiSpeedLimit, speedLimitTitle);
                     } else {
                         logger.debug("üîç EDGE {}: base={}, avoidance={}, speedLimit={}, total={}, hasSpeedLimit={}, isEds={}, isCustomArea={}, osmSpeedLimit={}, apiSpeedLimit={}", 
                                    edgeId, baseWeight, avoidanceWeight, speedLimitWeight, totalWeight, 
                                    hasSpeedLimit, isEdsEdge, isCustomAreaEdge, osmSpeedLimit, apiSpeedLimit);
                     }
                 }
            }
            
            return totalWeight;
        }
        
        @Override
        public double calcMinWeightPerDistance() {
            return baseWeighting.calcMinWeightPerDistance();
        }
        
                /**
         * Hƒ±z limit aƒüƒ±rlƒ±ƒüƒ±nƒ± hesapla - Request hints'ten veri al
         */
        private double calculateSpeedLimitWeight(EdgeIteratorState edgeState, boolean reverse) {
            int edgeId = edgeState.getEdge();
            int maxEdgeId = graph.getEdges();
            
            // Edge ID ge√ßerliliƒüini kontrol et
            if (edgeId < 0 || edgeId >= maxEdgeId) {
                logger.warn("Invalid edge ID in calculateSpeedLimitWeight: {} (max: {})", edgeId, maxEdgeId - 1);
                return 1.0; // Ge√ßersiz edge i√ßin n√∂tr aƒüƒ±rlƒ±k
            }
            
            // Request hints'ten hƒ±z limit verilerini al
            @SuppressWarnings("unchecked")
            Map<Integer, SpeedLimitService.SpeedLimitData> speedLimitData = 
                (Map<Integer, SpeedLimitService.SpeedLimitData>) requestHints.getObject("speed_limit_data", null);
            
            if (speedLimitData == null || !speedLimitData.containsKey(edgeId)) {
                return 1.0; // Hƒ±z limit verisi yok - n√∂tr aƒüƒ±rlƒ±k
            }
            
            SpeedLimitService.SpeedLimitData speedLimit = speedLimitData.get(edgeId);
            if (speedLimit == null || speedLimit.speedLimit <= 0) {
                return 1.0; // Ge√ßersiz hƒ±z limiti
            }
            
            // OSM'deki hƒ±z limitini al
            double osmSpeedLimit = getOsmSpeedLimit(edgeState, reverse);
            
            // OSM kar≈üƒ±la≈ütƒ±rma logunu INFO seviyesine √ßƒ±kar
            logger.info("üîç OSM COMPARISON: Edge {} - API Speed: {} km/h, OSM Speed: {} km/h", 
                       edgeId, speedLimit.speedLimit, osmSpeedLimit);
            
            // API'den gelen hƒ±z limiti ile OSM'deki hƒ±z limitini kar≈üƒ±la≈ütƒ±r
            if (speedLimit.speedLimit >= osmSpeedLimit) {
                // API hƒ±z limiti OSM'den y√ºksek veya e≈üit - hƒ±z farkƒ±na g√∂re dinamik bonus
                double speedDifference = speedLimit.speedLimit - osmSpeedLimit;
                double bonusFactor = calculateDynamicBonus(speedDifference);
                logger.info("‚úÖ SPEED BONUS: Edge {} - API({}) >= OSM({}) ‚Üí SpeedDiff: {} km/h, BonusFactor: {} (Dynamic Bonus applied)", 
                           edgeId, speedLimit.speedLimit, osmSpeedLimit, speedDifference, bonusFactor);
                return bonusFactor;
            } else {
                // API hƒ±z limiti OSM'den d√º≈ü√ºk - hƒ±z farkƒ±na g√∂re dinamik ceza
                double speedDifference = osmSpeedLimit - speedLimit.speedLimit;
                double penaltyFactor = calculateDynamicPenalty(speedDifference, osmSpeedLimit, speedLimit.speedLimit);
                logger.info("‚ö†Ô∏è SPEED PENALTY: Edge {} - API({}) < OSM({}) ‚Üí SpeedDiff: {} km/h, PenaltyFactor: {} (Dynamic Penalty applied)", 
                           edgeId, speedLimit.speedLimit, osmSpeedLimit, speedDifference, penaltyFactor);
                return penaltyFactor;
            }
        }
        
        /**
         * Ka√ßƒ±nma aƒüƒ±rlƒ±ƒüƒ±nƒ± hesapla - EDS √∂ncelikli olduƒüu i√ßin katƒ± ka√ßƒ±nma
         */
        private double calculateAvoidanceWeight(EdgeIteratorState edgeState, boolean reverse) {
            int edgeId = edgeState.getEdge();
            int maxEdgeId = graph.getEdges();
            
            // Edge ID ge√ßerliliƒüini kontrol et
            if (edgeId < 0 || edgeId >= maxEdgeId) {
                logger.warn("Invalid edge ID in calculateAvoidanceWeight: {} (max: {})", edgeId, maxEdgeId - 1);
                return 1.0; // Ge√ßersiz edge i√ßin n√∂tr aƒüƒ±rlƒ±k
            }
            
                         if (avoidEdsRoads) {
                 if (isEdsEdge(edgeId)) {
                     // EDS √∂ncelikli - kesinlikle ka√ßƒ±n
                     logger.info("üö® EDS AVOIDANCE: Edge {} detected as EDS road, applying strict avoidance (penalty: {})", 
                               edgeId, AVOIDANCE_PENALTY_FACTOR);
                     return AVOIDANCE_PENALTY_FACTOR; // Tam ceza
                 }
             }
            
                         if (avoidCustomAreas) {
                 if (isCustomAreaEdge(edgeId)) {
                     // Custom Area √∂ncelikli - kesinlikle ka√ßƒ±n
                     logger.info("üö® CUSTOM AREA AVOIDANCE: Edge {} detected as Custom Area road, applying strict avoidance (penalty: {})", 
                               edgeId, AVOIDANCE_PENALTY_FACTOR);
                     return AVOIDANCE_PENALTY_FACTOR; // Tam ceza
                 }
             }
            
            return 1.0; // Ka√ßƒ±nma yok veya bu edge ka√ßƒ±nƒ±lmasƒ± gereken bir edge deƒüil
        }
        
        /**
         * Edge'in EDS edge'i olup olmadƒ±ƒüƒ±nƒ± kontrol et
         */
        private boolean isEdsEdge(int edgeId) {
            // Edge ID ge√ßerliliƒüini kontrol et
            int maxEdgeId = graph.getEdges();
            if (edgeId < 0 || edgeId >= maxEdgeId) {
                logger.debug("Invalid edge ID in SpeedLimitAwareWeighting.isEdsEdge: {} (max: {})", edgeId, maxEdgeId - 1);
                return false;
            }
            
            try {
                // TrafficAwareCustomModelCreator'dan EDS edge set'ini al
                Set<Integer> edsEdgeIds = customModelCreator.getEdsEdgeIds();
                return edsEdgeIds != null && edsEdgeIds.contains(edgeId);
            } catch (Exception e) {
                logger.debug("Error checking EDS edge {}: {}", edgeId, e.getMessage());
                return false;
            }
        }
        
        /**
         * Edge'in Custom Area edge'i olup olmadƒ±ƒüƒ±nƒ± kontrol et
         */
        private boolean isCustomAreaEdge(int edgeId) {
            // Edge ID ge√ßerliliƒüini kontrol et
            int maxEdgeId = graph.getEdges();
            if (edgeId < 0 || edgeId >= maxEdgeId) {
                logger.debug("Invalid edge ID in SpeedLimitAwareWeighting.isCustomAreaEdge: {} (max: {})", edgeId, maxEdgeId - 1);
                return false;
            }
            
            try {
                // TrafficAwareCustomModelCreator'dan Custom Area edge set'ini al
                Set<Integer> customAreaEdgeIds = customModelCreator.getCustomAreaEdgeIds();
                return customAreaEdgeIds != null && customAreaEdgeIds.contains(edgeId);
            } catch (Exception e) {
                logger.debug("Error checking Custom Area edge {}: {}", edgeId, e.getMessage());
                return false;
            }
        }
        
        /**
         * Hƒ±z farkƒ±na g√∂re dinamik bonus hesapla
         */
        private double calculateDynamicBonus(double speedDifference) {
            // Hƒ±z farkƒ±na g√∂re dinamik bonus hesaplama
            // K√º√ß√ºk farklar i√ßin hafif bonus, b√ºy√ºk farklar i√ßin daha g√º√ßl√º bonus
            
            if (speedDifference <= 5) {
                // 0-5 km/h fark: %3 bonus
                return 0.97;
            } else if (speedDifference <= 15) {
                // 6-15 km/h fark: %5 bonus
                return 0.95;
            } else if (speedDifference <= 30) {
                // 16-30 km/h fark: %8 bonus
                return 0.92;
            } else if (speedDifference <= 50) {
                // 31-50 km/h fark: %12 bonus
                return 0.88;
            } else {
                // 50+ km/h fark: %15 bonus (maksimum)
                return 0.85;
            }
        }
        
        /**
         * Hƒ±z farkƒ±na g√∂re dinamik ceza hesapla
         */
        private double calculateDynamicPenalty(double speedDifference, double osmSpeed, double apiSpeed) {
            // Hƒ±z farkƒ±na g√∂re dinamik ceza hesaplama
            // K√º√ß√ºk farklar i√ßin hafif ceza, b√ºy√ºk farklar i√ßin daha g√º√ßl√º ceza
            
            if (speedDifference <= 5) {
                // 0-5 km/h fark: %3 ceza
                return 1.03;
            } else if (speedDifference <= 15) {
                // 6-15 km/h fark: %8 ceza
                return 1.08;
            } else if (speedDifference <= 30) {
                // 16-30 km/h fark: %15 ceza
                return 1.15;
            } else if (speedDifference <= 50) {
                // 31-50 km/h fark: %25 ceza
                return 1.25;
            } else {
                // 50+ km/h fark: %35 ceza (maksimum)
                return 1.35;
            }
        }
        
        /**
         * OSM'deki hƒ±z limitini al (eƒüer yoksa ara√ß tipine g√∂re varsayƒ±lan deƒüer)
         */
        private double getOsmSpeedLimit(EdgeIteratorState edgeState, boolean reverse) {
            // OSM'deki hƒ±z limitini al
            DecimalEncodedValue osmMaxSpeedEnc = new DecimalEncodedValueImpl("max_speed", 7, 0, 2, false, true, true);
            double osmSpeedLimit = osmMaxSpeedEnc.getDecimal(reverse, edgeState.getEdge(), graph.getEdgeAccess());
            
            // Eƒüer OSM'de hƒ±z limiti varsa onu kullan
            if (osmSpeedLimit != Double.POSITIVE_INFINITY && osmSpeedLimit > 0) {
                logger.debug("OSM Speed Limit found: {} km/h for edge {}", osmSpeedLimit, edgeState.getEdge());
                return osmSpeedLimit;
            }
            
            // OSM'de hƒ±z limiti yoksa ara√ß tipine g√∂re varsayƒ±lan deƒüer
            int defaultSpeed = getDefaultSpeedLimitForCarType(carTypeId);
            logger.debug("No OSM speed limit for edge {}, using default: {} km/h for car type {}", 
                        edgeState.getEdge(), defaultSpeed, carTypeId);
            return defaultSpeed;
        }
        
        /**
         * Ara√ß tipine g√∂re varsayƒ±lan hƒ±z limiti getir (≈ûehir i√ßi i√ßin makul seviyeler)
         */
        private int getDefaultSpeedLimitForCarType(int carTypeId) {
            switch (carTypeId) {
                case 1: return 50; // Otomobil - ≈ûehir i√ßi 50 km/h
                case 2: return 50; // Minib√ºs - ≈ûehir i√ßi 50 km/h
                case 3: return 50; // Otob√ºs - ≈ûehir i√ßi 50 km/h
                case 4: return 45; // Kamyonet - ≈ûehir i√ßi 45 km/h
                case 5: return 40; // Kamyon - ≈ûehir i√ßi 40 km/h
                case 6: return 40; // √áekici - ≈ûehir i√ßi 40 km/h
                default: return 45; // Varsayƒ±lan ≈üehir i√ßi hƒ±z limiti
            }
        }
        
        @Override
        public long calcEdgeMillis(EdgeIteratorState edgeState, boolean reverse) {
            return baseWeighting.calcEdgeMillis(edgeState, reverse);
        }
        
        @Override
        public double calcTurnWeight(int inEdge, int viaNode, int outEdge) {
            return baseWeighting.calcTurnWeight(inEdge, viaNode, outEdge);
        }
        
        @Override
        public long calcTurnMillis(int inEdge, int viaNode, int outEdge) {
            return baseWeighting.calcTurnMillis(inEdge, viaNode, outEdge);
        }
        
        @Override
        public boolean hasTurnCosts() {
            return baseWeighting.hasTurnCosts();
        }
        
        @Override
        public String getName() {
            return "speed_limit_aware";
        }
        
        @Override
        public String toString() {
            return String.format("SpeedLimitAwareWeighting{carType=%d, avoidEDS=%s, avoidCustomAreas=%s}", 
                               carTypeId, avoidEdsRoads, avoidCustomAreas);
        }
    }
    
    /**
     * Sadece ka√ßƒ±nma weighting'i (hƒ±z limiti olmadan)
     */
    public class AvoidanceOnlyWeighting implements Weighting {
        private final Weighting baseWeighting;
        private final boolean avoidEdsRoads;
        private final boolean avoidCustomAreas;
        
        private static final double AVOIDANCE_PENALTY_FACTOR = 10.0;  // Ka√ßƒ±nƒ±lmasƒ± gereken yollar i√ßin b√ºy√ºk ceza
        
        public AvoidanceOnlyWeighting(Weighting baseWeighting, boolean avoidEdsRoads, boolean avoidCustomAreas) {
            this.baseWeighting = baseWeighting;
            this.avoidEdsRoads = avoidEdsRoads;
            this.avoidCustomAreas = avoidCustomAreas;
        }
        
        @Override
        public double calcEdgeWeight(EdgeIteratorState edgeState, boolean reverse) {
            // Edge ID ge√ßerliliƒüini kontrol et
            int edgeId = edgeState.getEdge();
            int maxEdgeId = graph.getEdges();
            
            if (edgeId < 0 || edgeId >= maxEdgeId) {
                logger.warn("Invalid edge ID in AvoidanceOnlyWeighting: {} (max: {})", edgeId, maxEdgeId - 1);
                // Ge√ßersiz edge i√ßin base weighting'i d√∂nd√ºr
                return baseWeighting.calcEdgeWeight(edgeState, reverse);
            }
            
            // Base weighting'i hesapla
            double baseWeight = baseWeighting.calcEdgeWeight(edgeState, reverse);
            
            // Sadece ka√ßƒ±nma aƒüƒ±rlƒ±ƒüƒ±nƒ± hesapla
            double avoidanceWeight = calculateAvoidanceWeight(edgeState, reverse);
            
            // Toplam aƒüƒ±rlƒ±ƒüƒ± hesapla
            double totalWeight = baseWeight * avoidanceWeight;
            
            // Debug log
            if (logger.isDebugEnabled()) {
                boolean isEdsEdge = isEdsEdge(edgeId);
                boolean isCustomAreaEdge = isCustomAreaEdge(edgeId);
                
                if (isEdsEdge || isCustomAreaEdge) {
                    logger.debug("AvoidanceOnly Edge {}: base={}, avoidance={}, total={}, isEds={}, isCustomArea={}", 
                               edgeId, baseWeight, avoidanceWeight, totalWeight, isEdsEdge, isCustomAreaEdge);
                }
            }
            
            return totalWeight;
        }
        
        /**
         * Ka√ßƒ±nma aƒüƒ±rlƒ±ƒüƒ±nƒ± hesapla (katƒ± ka√ßƒ±nma)
         */
        private double calculateAvoidanceWeight(EdgeIteratorState edgeState, boolean reverse) {
            int edgeId = edgeState.getEdge();
            int maxEdgeId = graph.getEdges();
            
            // Edge ID ge√ßerliliƒüini kontrol et
            if (edgeId < 0 || edgeId >= maxEdgeId) {
                logger.warn("Invalid edge ID in AvoidanceOnlyWeighting.calculateAvoidanceWeight: {} (max: {})", edgeId, maxEdgeId - 1);
                return 1.0; // Ge√ßersiz edge i√ßin n√∂tr aƒüƒ±rlƒ±k
            }
            
            if (avoidEdsRoads && isEdsEdge(edgeId)) {
                logger.debug("EDS edge detected ({}), applying strict avoidance", edgeId);
                return AVOIDANCE_PENALTY_FACTOR; // Tam ceza
            }
            
            if (avoidCustomAreas && isCustomAreaEdge(edgeId)) {
                logger.debug("Custom Area edge detected ({}), applying strict avoidance", edgeId);
                return AVOIDANCE_PENALTY_FACTOR; // Tam ceza
            }
            
            return 1.0; // Ka√ßƒ±nma yok veya bu edge ka√ßƒ±nƒ±lmasƒ± gereken bir edge deƒüil
        }
        
        /**
         * Edge'in EDS edge'i olup olmadƒ±ƒüƒ±nƒ± kontrol et
         */
        private boolean isEdsEdge(int edgeId) {
            // Edge ID ge√ßerliliƒüini kontrol et
            int maxEdgeId = graph.getEdges();
            if (edgeId < 0 || edgeId >= maxEdgeId) {
                logger.debug("Invalid edge ID in AvoidanceOnlyWeighting.isEdsEdge: {} (max: {})", edgeId, maxEdgeId - 1);
                return false;
            }
            
            try {
                // TrafficAwareCustomModelCreator'dan EDS edge set'ini al
                Set<Integer> edsEdgeIds = customModelCreator.getEdsEdgeIds();
                return edsEdgeIds != null && edsEdgeIds.contains(edgeId);
            } catch (Exception e) {
                logger.debug("Error checking EDS edge {}: {}", edgeId, e.getMessage());
                return false;
            }
        }
        
        /**
         * Edge'in Custom Area edge'i olup olmadƒ±ƒüƒ±nƒ± kontrol et
         */
        private boolean isCustomAreaEdge(int edgeId) {
            // Edge ID ge√ßerliliƒüini kontrol et
            int maxEdgeId = graph.getEdges();
            if (edgeId < 0 || edgeId >= maxEdgeId) {
                logger.debug("Invalid edge ID in AvoidanceOnlyWeighting.isCustomAreaEdge: {} (max: {})", edgeId, maxEdgeId - 1);
                return false;
            }
            
            try {
                // TrafficAwareCustomModelCreator'dan Custom Area edge set'ini al
                Set<Integer> customAreaEdgeIds = customModelCreator.getCustomAreaEdgeIds();
                return customAreaEdgeIds != null && customAreaEdgeIds.contains(edgeId);
            } catch (Exception e) {
                logger.debug("Error checking Custom Area edge {}: {}", edgeId, e.getMessage());
                return false;
            }
        }
        
        @Override
        public double calcMinWeightPerDistance() {
            return baseWeighting.calcMinWeightPerDistance();
        }
        
        @Override
        public long calcEdgeMillis(EdgeIteratorState edgeState, boolean reverse) {
            return baseWeighting.calcEdgeMillis(edgeState, reverse);
        }
        
        @Override
        public double calcTurnWeight(int inEdge, int viaNode, int outEdge) {
            return baseWeighting.calcTurnWeight(inEdge, viaNode, outEdge);
        }
        
        @Override
        public long calcTurnMillis(int inEdge, int viaNode, int outEdge) {
            return baseWeighting.calcTurnMillis(inEdge, viaNode, outEdge);
        }
        
        @Override
        public boolean hasTurnCosts() {
            return baseWeighting.hasTurnCosts();
        }
        
        @Override
        public String getName() {
            return "avoidance_only";
        }
        
        @Override
        public String toString() {
            return String.format("AvoidanceOnlyWeighting{avoidEDS=%s, avoidCustomAreas=%s}", 
                               avoidEdsRoads, avoidCustomAreas);
        }
    }
} 